# Croupier describes a task graph and lets you operate on them
require "digest/sha1"
require "yaml"
require "crystalline"
require "log"
require "./topo_sort"

module Croupier
  VERSION = "0.1.0"

  # A Task is a code that generates an output file
  #
  # It can have one or more inputs, which may also be outputs of other tasks
  # It has a descriptive `name` which should be understandable to the user
  # It has a `Proc` which is executed when the task is run

  class Task
    # Registry of all tasks
    @@tasks = {} of String => Task

    def self.tasks
      @@tasks
    end

    def self.task(output)
      @@tasks[output]
    end

    # Tasks as a dependency graph sorted topologically
    def self.sorted_task_graph
      # First, we create the graph
      g = Crystalline::Graph::DirectedAdjacencyGraph(String, Set(String)).new

      # Add all tasks and inputs as vertices
      # Add all dependencies as edges

      # The start node is just a convenience
      g.add_vertex "start"
      all_inputs.each do |input|
        if !@@tasks.has_key? input
          g.add_vertex input
          g.add_edge "start", input
        end
      end

      @@tasks.each do |output, task|
        g.add_vertex output
        if task.@inputs.empty?
          g.add_edge "start", output
        end
        task.@inputs.each do |input|
          g.add_edge input, output
        end
      end

      # Only return tasks, not inputs in the sorted graph
      return g, topological_sort(g.@vertice_dict).select { |v| @@tasks.has_key? v }
    end

    # Registry of modified files, which will make tasks stale
    @@modified = Set(String).new

    def self.modified
      @@modified
    end

    # Mark one file as modified
    def self.mark_modified(file)
      @@modified << file
    end

    # Mark all files as unmodified (only meant for testing)
    def self.clear_modified
      @@modified.clear
    end

    # Remove all tasks and everything else (good for tests)
    def self.cleanup
      self.clear_modified
      @@tasks = {} of String => Task
      @@last_run = {} of String => String
      @@this_run = {} of String => String
      @@next_run = {} of String => String
    end

    # SHA1 of files from last run
    @@last_run = {} of String => String
    # SHA1 of files as of starting this run
    @@this_run = {} of String => String
    # SAH1 of input files as of ending this run
    @@next_run = {} of String => String

    # All inputs from all tasks
    def self.all_inputs
      @@tasks.values.flat_map { |task| task.@inputs }.uniq!
    end

    # Read state of last run, then scan inputs and compare
    def self.mark_stale
      if File.exists? ".croupier"
        @@last_run = File.open(".croupier") do |file|
          YAML.parse(file).as_h.map { |k, v| [k.to_s, v.to_s] }.to_h
        end
      else
        @@last_run = {} of String => String
      end
      (@@this_run = scan_inputs).each do |file, sha1|
        if @@last_run.fetch(file, "") != sha1
          mark_modified(file)
        end
      end
    end

    # Scan all inputs and return a hash with their sha1
    def self.scan_inputs
      self.all_inputs.reduce({} of String => String) do |hash, file|
        if File.exists? file
          hash[file] = Digest::SHA1.hexdigest(File.read(file))
        end
        hash
      end
    end

    # Run all stale tasks in dependency order
    #
    # If `run_all` is true, run non-stale tasks too
    def self.run_tasks(run_all : Bool = false)
      mark_stale
      _, tasks = Task.sorted_task_graph
      tasks.each do |task|
        if @@tasks.has_key?(task) && (run_all || @@tasks[task].stale?)
          path = @@tasks[task].@output
          data = @@tasks[task].run

          if @@tasks[task].@no_save
            if File.exists? path
              data = File.read(path)
            else
              Log.warn { "Task #{@@tasks[task]} did not generate #{path}" }
              next
            end
          else # Save the file
            Dir.mkdir_p(File.dirname path)
            File.open(path, "w") do |io|
              io.puts data
            end
          end

          @@next_run[path] = Digest::SHA1.hexdigest(data)
        end
      end

      # We ran all tasks, store the current state
      File.open(".croupier", "w") do |file|
        file.puts YAML.dump(@@this_run.merge @@next_run)
      end
    end

    @proc : Proc(String)

    def initialize(name : String, output : String, inputs : Array(String), proc : Proc(String), no_save = false)
      if inputs.includes?(output)
        raise "Cycle detected"
      end
      @name = name
      @proc = proc
      @output = output
      @inputs = inputs
      @stale = false
      @no_save = no_save
      if @@tasks.has_key? output
        # Can't have two tasks generating the same output
        raise "Task conflict: #{name} would generate #{output} which is already generated by #{@@tasks[output]}"
      end
      @@tasks[output] = self
    end

    # This should generate the output file
    def run : String
      @proc.call
    end

    # Tasks are stale if any of their inputs are stale
    def stale?
      @stale = (
        @inputs.any? { |input| @@modified.includes? input } ||
        @inputs.any? { |input| @@tasks.has_key?(input) && @@tasks[input].stale? }
      )
    end

    def to_s(io)
      io << "#{@name}::#{@output}"
    end
  end
end
