# Croupier describes a task graph and lets you operate on them
require "digest/sha1"
require "crystalline"

module Croupier
  VERSION = "0.1.0"

  # A Task is a block of code that generates an output file
  #
  # It can have one or more inputs, which may also be outputs of other tasks
  # It has a descriptive `name` which should be understandable to the user
  # It has a `Proc` which is executed when the task is run

  class Task
    # Registry of all tasks
    @@Tasks = {} of String => Task

    def self.tasks
      @@Tasks
    end

    # Tasks as a dependency graph sorted topologically
    def self.sorted_task_graph
      g = Crystalline::Graph::DirectedAdjacencyGraph(String, Set(String)).new

      g.add_vertex "root"

      @@Tasks.each do |output, task|
        g.add_vertex output
        if task.@inputs.empty?
          g.add_edge "root", output
        else
          task.@inputs.each do |input|
            g.add_edge input, output
          end
        end
      end
      # Connect all subgraphs
      all_inputs.each do |input|
        if !@@Tasks.has_key? input
          g.add_vertex input
          g.add_edge "root", input
        end
      end
      # Ensure there are no loops
      dfs = Crystalline::Graph::DFSIterator.new(g, "root")
      dfs.back_edge_event = ->(u : String, v : String) {
        raise "Cycle detected between #{u} and #{v}"
      }
      sorted = [] of String
      dfs.each { |v| sorted << v }
      return g, sorted
    end

    # Registry of modified files, which will make tasks stale
    @@Modified = Set(String).new

    def self.mark_modified(file)
      @@Modified << file
    end

    # SHA1 of files from last run
    @@LastRun = {} of String => String

    # All inputs from all tasks
    def self.all_inputs
      @@Tasks.values.map { |task| task.@inputs }.flatten.uniq
    end

    # Scan all inputs and return a hash with their sha1
    def self.scan_inputs
      self.all_inputs.reduce({} of String => String) do |hash, file|
        hash[file] = Digest::SHA1.hexdigest(File.read(file))
        hash
      end
    end

    # Run all tasks in dependency order
    def self.run_tasks
      _, tasks = Task.sorted_task_graph
      tasks.each do |task|
        if @@Tasks.has_key? task
          @@Tasks[task].run
        end
      end
    end

    @block : Proc(Nil)

    def initialize(name : String, output : String, inputs : Array(String), block : Proc)
      if inputs.includes?(output)
        raise "Cycle detected"
      end
      @name = name
      @block = block
      @output = output
      @inputs = inputs
      @stale = false
      if @@Tasks.has_key? output
        # Can't have two tasks generating the same output
        raise "Task conflict: #{name} would generate #{output} which is already generated by #{@@Tasks[output].@name}"
      end
      @@Tasks[output] = self
    end

    # This should generate the output file
    def run
      @block.call
      # Since we just generated it, output is modified and Task is not stale
      @stale = false
    end

    # Tasks are stale if any of their inputs are stale
    def stale?
      @stale = (
        @inputs.any? { |input| @@Modified.includes? input } ||
        @inputs.any? { |input| @@Tasks.has_key?(input) && @@Tasks[input].stale? }
      )
    end

    def to_s(io)
      io.puts "#{@name}::#{@output}"
    end
  end
end
